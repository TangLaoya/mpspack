\documentclass[12pt]{article}
\usepackage{graphicx,bm,amssymb,amsmath,amsthm}

% timo macros
\newcommand{\bx}{\textbf{x}}
\newcommand{\by}{\textbf{y}}
\newcommand{\bs}{\textbf{s}}

% alex macros
\newcommand{\bi}{\begin{itemize}}
\newcommand{\ei}{\end{itemize}}
\newcommand{\ben}{\begin{enumerate}}
\newcommand{\een}{\end{enumerate}}
\newcommand{\be}{\begin{equation}}
\newcommand{\ee}{\end{equation}}
\newcommand{\bea}{\begin{eqnarray}}
\newcommand{\eea}{\end{eqnarray}}
\newcommand{\bc}{\begin{center}}
\newcommand{\ec}{\end{center}}
\newcommand{\spl}[2]{\left\{\begin{array}{ll}#1\\#2\end{array}\right.}
\newcommand{\ie}{{\it i.e.\ }}
\newcommand{\eg}{{\it e.g.\ }}
\newcommand{\pd}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\pdc}[3]{\left. \frac{\partial #1}{\partial #2}\right|_{#3}}
\newcommand{\infint}{\int_{-\infty}^{\infty} \!\!}      % infinite integral
\newcommand{\tbox}[1]{{\mbox{\tiny #1}}}
\newcommand{\mbf}[1]{{\bm #1}}           % requires bm package
\newcommand{\pO}{{\partial\Omega}}
\newcommand{\uN}{u^{(N)}}
\newcommand{\emach}{\epsilon_\tbox{mach}}
%\newcommand{\crk}{C_{s}} %C_{R,k}         % const for exponential s(m) bnd
\newcommand{\bmp}[1]{\begin{minipage}{#1}}
\newcommand{\emp}{\end{minipage}}

\newtheorem{thm}{Theorem}
\newtheorem{cnj}{Conjecture}
\newtheorem{lem}{Lemma}[thm]
\newtheorem{cor}{Corollary}[thm]

\newtheorem{rmk}[thm]{Remark}
\newtheorem{pro}[thm]{Proposition}
%\newtheorem{cnj}[thm]{Conjecture}
%\newtheorem{lemma}[thm]{Lemma}

\newcommand{\bp}{{\bf Proof:\ }}   % {\begin{proof}}
\newcommand{\ep}{\hfill $\square$ \vspace{1ex} \\} % {\end{proof}}
% note elsart ones horrible: \pr and \endpr
\newcommand{\bmal}{{\bm \alpha}}             % bold alpha
\newcommand{\xx}{\mbf{x}}             % bold x
\newcommand{\splt}[2]{$\left\{\begin{array}{l}\mbox{#1}\\\mbox{#2}\end{array}\ri
ght.$}
\newcommand{\lo}{{L^2(\Omega)}}
\newcommand{\lpo}{{L^2(\pO)}}
\newcommand{\cu}{\tilde{u}}            % symbol for continuation of u
\newcommand{\cOmega}{\tilde{\Omega}}   % symbol for domain to be continued into
\newcommand{\dmax}{D_\tbox{max}}       % max dist in splane_charge_curve

\newcommand{\tw}{\textwidth}
\newcommand{\vg}{\vspace{2ex}}
 

\begin{document}
\title{{\tt MPSpack} user manual}
\author{Alex Barnett\footnote{Department of Mathematics, Dartmouth College, Hanover, NH, 03755, USA}
and Timo Betcke\footnote{School
of Mathematics, The University of Manchester,
  Manchester, M13 9PL, UK}}
\date{code revision 14: \today}

\maketitle
\begin{abstract}
{\tt MPSpack} is a fully object-oriented MATLAB toolbox that implements the Method of Particular Solutions and related methods (\eg fundamental solutions) for efficient solution of Laplace eigenvalue, interior/exterior Helmholtz problems (\eg wave scattering), and related problems, on piecewise-constant 2D domains.
It is designed to be simple to use, and to enable highly-accurate solutions.
This is the user manual.
\end{abstract}

\section{Installation}

Requirements:
\bi
\item MATLAB version 7.6 (2008a) or newer.
\ei

We make use of the object-oriented programming ability of MATLAB which
unfortunately means the toolbox cannot work with versions earlier than 7.6.


The project is hosted at
{\tt http://code.google.com/p/mpspack}


Anonymous check out of the package is via the subversion command:

{\tt svn checkout http://mpspack.googlecode.com/svn/trunk/ mpspack-read-only}

This creates a directory {\tt mpspack-read-only} in which you will find
the {\tt mpspack} subdirectory.



Setting up MATLAB path\ldots


\section{Overview}

{\tt MPSpack} is a MATLAB toolbox to solve Helmholtz boundary-value
problems (BVP) and
eigenvalue problems (EVP) with particular and fundamental solution methods.

Define BVP, EVP

To solve a BVP the usual flow is as follows:

\ben
\item define piecewise-analytic segments forming all boundaries
\item define domains using various of these segments as their boundaries
\item choose MPS basis set(s) within each domain
\item set up inhomogeneous boundary or matching conditions on each segment
\item solve a %least-squares
linear system to get the basis coefficient vector
\item evaluate solution on desired points
\item plot solution or compute error estimates
\een

\ldots

\subsection{Geometry}

\ldots

When domains are built from segments, each segment stores information about
which domain, if any, it is connected to on each side.
If segments are to be reused to construct new domains, while erasing any
old domains, the current way to do this is via the {\tt segment.disconnect(s)}
command, where {\tt s} is an array of segment handles. This clears
these segments of any connections with domains.

\ldots

\subsection{Boundary conditions}

A segment $\Gamma$ may contain a boundary condition on only one of its sides,
of the form
$$
a u(s) + b u_n(s) = f(s)  \qquad s\in\Gamma, \quad a,b \in \mathbb{C}
$$
or, alternatively matching conditions of the form
\bea
%\left.\begin{array}{rcl}
a^+ u^+(s) + a^- u^-(s) &=& f(s)\\
b^+ u_n^+(s) + b^- u_n^-(s) &=& g(s)
\eea
where $a^+,a^-,b^+,b^- \in \mathbb{C}$.
In the above $f$ and $g$ are functions on the boundary.
In our implementation the user
may supply these as handles to functions of position, or as data on the segment
quadrature points.

\section{In-depth examples}

\section{Test routines}

The code {\tt testbvp.m} shows the main steps for solution of a BVP on
a variety of domains.

\section{Limitations}

\bi
\item Checking of whether inside a domain is approximate, based on approximating
polygons.
\ei

\section{List of improvements to make}

List to be prioritized:

\bi
\item make {\tt segment.bdryfunc} which creates $u$, $u_n$ data given a
field function and its gradient field function, useful for choosing BC
data corresponding to exact fields
\item make {\tt domain.setbc} which uses one BC data function on all segments
\item eigenvalue problems: MPS, scaling method
\item segment methods to create analytic interpolant function from boundary
point data, enabling user to specify a segment using points on a curve.
\item add MFS basis, real and complex
\item add automated ways to choose MFS charge points
\item add layer-potential bases, and associated periodic quadrature methods
\item write {\tt segment.bdrysolution} which evaluates $u$, $u_n$ on one
or other side of a boundary. For layer potentials this would take into account
jump relations.
\item keep discrepancy and evaluation matrices, for efficiency in multiple
right-hand sides.
\item classes which symmetrize basis sets for single reflection, $C_4$, etc
symmetry, by wrapping the calls to basis evaluations using reflection
points
\item dielectric constants, overall frequency,
automatically changing $k$ in domains
\ei

\section{Known bugs}

Please alert the authors to any bugs you discover, including a description
of how to reproduce the behavior, using the interface at

{\tt http://code.google.com/p/mpspack/issues/list}

\bibliographystyle{siam} 
\bibliography{alexrefs}



\end{document}
