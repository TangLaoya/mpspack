\appendix

\setlength{\parskip}{\baselineskip}
\setlength{\parindent}{0pt}

\section{Class Descriptions}


\paragraph{POINTSET}

Create a pointset object with locations and normal vectors as
complex numbers.

A pointset is simple object containing a list of points in 2D, plus possibly
associated normal directions.  It is used to store quadrature points on a
segment, and also evaluation point lists. Coordinates are stored as 
complex numbers.

\textbf{Constructors}

\textbf{p = POINTSET()}
creates an empty object.
 
\textbf{p = POINTSET(x)} where x is m-by-1 array, creates pointset with m points, where
the ith point has Cartesian coordinates (Re x(i), Im x(i)).
  
\textbf{p = POINTSET(x, nx)} where x is above and nx has same size as x, creates
pointset with coordinates x (interpreted as above) and associated normals
nx (interpreted in the same way). The Euclidean lengths of the vectors in
nx are not required to be, nor changed to, unity.

See also: POINTSET/plot, SEGMENT which builds on POINTSET

\textbf{Methods}

none


\newpage

\paragraph{SEGMENT} create segment object

\textbf{Constructors}

\textbf{s = SEGMENT(M, [xi xf])}  creates a line segment object from xi to xf, both
complex numbers.

\textbf{s = SEGMENT(M, [xc R ti tf])} creates a circular arc segment with center
xi, radius R and angles from ti to tf. The order is important. If tf>ti
the orientation is counter-clockwise, otherwise clockwise.
  
\textbf{s = SEGMENT(M, {Z, Zp})} creats an analytic curve given by the image of 
the analytic function Z:[0,1]->C. Zp must be the derivative of Z. 
Z and Zp are function handles. 
  
\textbf{s = SEGMENT(M, {Z, Zp, Zpp})} works as above but also takes the second
derivative Z'' of Z. This is useful for layer potentials.
 
\textbf{s = SEGMENT(M, p, qtype)} where p is any of the above, chooses quadrature type\\
    qtype = 'p': periodic trapezoid (appropriate for periodic segments, M pts)\\
          't': trapezoid rule (ie, half each endpoint, M+1 pts)\\
           'c': Clenshaw-Curtis (includes endpoints, M+1 pts)\\
           'g': Gauss (takes $O(M^3)$ to compute, M pts)\\

If M is empty, a default value of 20 is used.

\textbf{s = SEGMENT()} creates an empty segment object.

See also: POINTSET, segment/PLOT

\textbf{Methods}

\textbf{requadrature(segs, M, qtype)} change a segment's quadrature
scheme or number of points

\textbf{setbc(seg, pm, a, b, f)} set a (in)homogeneous boundary
condition on a segment

\textbf{setmatch(seg, a, b, f, g)} set (in)homogeneous matching
conditions across a segment 

\textbf{newseg = scale(seg, fac)} rescale (dilate) a segment (or list)
about the origin

\textbf{newseg = translate(seg, a)} translate a segment (or list of segments)

\textbf{newseg = rotate(seg, t)} rotate a segment (or list of
segments) about the origin

\textbf{newseg = reflect(seg, ax)} reflect a segment (or list of
segments) about x or y axis

\textbf{disconnect(segs)} disconnect a segment or segment list from any domains

\textbf{h = plot(s, pm, o)} plots a directed segment on current
figure, using its quadrature pts


\textbf{s = polyseglist(M, p, qtype)}\\
\textbf{s = polyseglist(M, p)}\\
(Static Method) create closed list of segment objects from CCW polygon vertices

\textbf{s = radialfunc(M, fs)} (Static Method) closed segment from
radial function r=f(theta) and derivatives

\textbf{s = smoothstar(M, a, w)} (Static Method) single-freq
oscillatory radial function closed segment

\textbf{[a b] = dielectriccoeffs(pol, np, nm)} (Static Method) give a
and b coeff pairs (1-by-2) from refractive indices


 
\newpage

\paragraph{DOMAIN} create an interior/exterior domain possibly with
excluded subregions

A domain is an ordered connected list of segments defining the exterior
boundary, with zero or more ordered connected lists of segments defining the
boundaries of any interior excluded regions. If the exterior boundary is empty
the domain from which interior regions are possibly excluded is taken to be
the whole plane, resulting in an unbounded exterior domain.

\textbf{Constructors}

\textbf{d = DOMAIN(s, pm)} creates an interior domain whose boundary is the list
of handles of segment objects s, using the list of senses pm (each element
is the number +1 or -1). A warning is given if the segments do not appear
to connect up at corners. Normals should all point outwards, ie away from
the domain, otherwise a warning is given. If pm has only 1 element, it will
be duplicated as necessary to match the size of s.

\textbf{d = DOMAIN()}\\
\textbf{d = DOMAIN([], [])}\\
creates an exterior domain equal to the
whole plane $\mathbb{R}^2$.

\textbf{d = DOMAIN([], [], si, pmi)} creates an exterior domain equal to the whole
plane minus an excluded region whose (non-intersecting) boundary is given
by segment list si and sign list pmi (which have the same format as s, pm
above). If si and pmi are instead cell arrays of segment lists and
corresponding sign lists, each cell element is an excluded region. As
above, warnings are given if intersections or incorrect normals are found.

\textbf{d = DOMAIN(s, pm, si, pmi)} combines the above features, creating a bounded
domain with excluded region(s).

See also: SEGMENT, domain/PLOT

\textbf{Methods}

\textbf{norout = normalscheck(d)} check that senses of normals point
away from a domain

\textbf{i = inside(d, p)} return true (false) for points inside
(outside) a domain

\textbf{x = x(d)} return column vector of quadrature points on a domain boundary

\textbf{nx = nx(d)} return column vector of unit outward normals on a
domain boundary

\textbf{w = w(d)} return row vector of quadrature weights for a domain
boundary

\textbf{bb = boundingbox(d)} return bounding [xmin xmax ymin ymax] for
interior domain

\textbf{xc = center(d)} return center x (as complex number) of bounding
box of domain 

\textbf{diam = diam(d)} approximate diameter of an interior domain

\textbf{[zz ii gx gy] = grid(d, dx)} make grid covering interior
domain, or some of exterior domain

\textbf{deletecorner(d,j)} remove a given corner number from a domain

\textbf{Nf = Nf(d)} total number of basis functions (dofs) associated
with domain

\textbf{clearbases(d)} remove all basis set associations from a domain

\textbf{showbasesgeom(d)} show geometry of basis objs

\textbf{addconnectedsegs(d, s, pm, o)} append a domain's params,
corners given conn seg list

\textbf{addregfbbasis(d, origin, N, opts)} create a regular
Fourier-Bessel basis object in a domain

\textbf{addnufbbasis(d,origin,nu,offset,branch,N,opts)} create a
fractional-order Fourier-Bessel basis set

\textbf{addcornerbases(d, N, opts)} add irreg Fourier-Bessel basis to
each corner of a domain

\textbf{addrpwbasis(d, N, opts)} create a real plane wave basis object
in a domain

\textbf{addmfsbasis(d, varargin} Add an MFS (fundamental solutions)
basis to a domain

\textbf{b = addlayerpot(d, a, segs, opts)} create a layer-potential
basis set object in a domain

\textbf{[A A1 A2] = evalbases(d, p, opts)} evaluate all basis sets in
a domain object, on a pointset

\textbf{h = plot(d, o)} show domain (or list of domains) on current figure

\textbf{setrefractiveindex(doms, n)} sets n for a list of domains

\textbf{v = approxpolygon(seg, pm)} (Static Method) stack together
approximating polygon vertices of segment list

\textbf{h = showsegments(seg, pm, o)} plot signed segment list to
current figure (domain helper)

\textbf{x = stackquadpts(seg, pm)} helper routine, ordered quad pts
from signed connected seg list 

\textbf{h = showdomains(dlist, opts)} plot all domains on current
figure using a color for each




























%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% End: 
