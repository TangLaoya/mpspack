\documentclass[12pt]{article}
\usepackage{graphicx,bm,amssymb,amsmath,amsthm}
\input{macros}

\begin{document}
\title{\mpspack\ user manual}
\author{Alex Barnett\footnote{Department of Mathematics, Dartmouth College, Hanover, NH, 03755, USA}
\ and Timo Betcke\footnote{Department of Mathematics,
University of Reading, Berkshire, RG6 6AX, UK}}
\date{\today}   % how pipe from getrevisionnumber + 1?

\maketitle
\begin{abstract}
\mpspack\ is a fully object-oriented \matlab\ toolbox for
solving Laplace, Helmholtz, wave scattering, and related PDE boundary-value
problems
on piecewise-homogeneous 2D domains, including those with corners.
The philosophy is to
%represent solutions using
use basis functions
which are particular solutions to the
PDE in some region; solving is thus reduced to matching on
the boundary (or on boundaries of subregions).
This idea is known as the Method of Particular Solutions, or as Trefftz,
ultra-weak, or non-polynomial 
methods in the FEM community.
Basis functions include plane-wave, Fourier-Bessel,
corner-adapted expansions, and
fundamental solutions.
Layer potential representations and associated
singular quadrature schemes are also available.
It is designed to
be simple to use, and to enable highly-accurate solutions.  This is
the user manual; for a more hands-on approach and worked examples
see the accompanying tutorial.
\end{abstract}


\bfi % ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
\ig{width=\textwidth}{hard.eps}
\ca{Sound-hard (homogeneous Neumann boundary condition) scattering from a smooth
obstacle using a fundamental solutions basis in \mpspack.
Left: incident wave. Center: scattered wave.
Right: total solution field.}{f:hard}
\efi


\section{Overview}
\label{s:overview}

In numerical analysis there has been recent excitement
in methods for solving linear PDEs where solutions are approximated by
linear combinations of {\em particular solutions} to the PDE.
These methods are high-order (often exponentially convergent),
efficient at high frequencies (the number of degrees of freedom $N$
scales linearly with wavenumber, in 2D),
and are quite simple to implement.
When geometries become more complicated, the domain needs to be split
up into multiple subdomains, e.g.\ one for each corner, and the
implementation and matrix construction becomes cumbersome.
The goal of this software toolbox is to make implementation of
these methods simple
and transparent, and create an intuitive, unifying framework in which many
types of boundary-value problems,
boundary conditions, and domain geometries
may be solved, explored and visualized with ease.
In these methods there is either no mesh (as in
fundamental solutions methods), or
the number of subdomains is small and fixed
(so-called $p$-FEM).
Thus we leave the job of specifying subdomains, i.e.\ `meshing',
to the user---this contrasts with the large number of
finite-element packages already in existence.
The benefit of such methods is their rapid convergence and efficiency.
The solution boils down to dense least-squares linear algebra,
which despite the $O(N^3)$ cost enables some quite high-frequency problems
to be solved.

We focus on the scalar homogeneous
Helmholtz equation in the plane,
\bea
(\Delta+k^2)u& =& 0 \qquad \mbox{in } \Omega~,
\eea
where $\Omega \subset \mathbb{R}^2$ is an interior or exterior
domain, $k\ge 0$ is the wavenumber, and certain
%imhomogeneous
linear boundary conditions are imposed.
Such problems arise in wave scattering and cavity resonances.
In \mpspack\ we use the (recently-acquired)
power of \matlab\ \cite{matlab} {\em object-oriented}
programming to represent the 
mathematical objects such as segments, domains,
basis sets, and BVPs, by software objects that may be manipulated
just like variables.
The result is that complicated problems may be set up and solved in
a few lines of quite-readable code.
For example, to solve and plot the scattering
of plane-wave incident from a smooth sound-hard (Neumann) domain
10 wavelengths in size, we can type,
\begin{verbatim}
s = segment.radialfunc(250, {@(q) 1 + 0.3*cos(3*q), @(q) -0.9*sin(3*q)});
d = domain([], [], s, -1);
s.setbc(1, 'N', []);
opts.tau = 0.04; d.addmfsbasis(s, 210, opts);
p = scattering(d, []);
p.setoverallwavenumber(30);
p.setincidentwave(pi/6);
p.solvecoeffs;
p.showthreefields;
\end{verbatim}
which produces Fig.~\ref{f:hard} in about 1 sec of CPU time,
to an accuracy of $10^{-9}$ (boundary condition $L^2$-norm).

More generally we may have multiple domains with different
wavenumbers connected by homogeneous or inhomogeneous boundary conditions,
as in transmission, dielectric-coated, acoustic or photonics problems.
With $k=0$ we have Laplace's equation, with applications to
electrostatics, steady-state heat flow, and probability.
In this release we discuss only boundary-value problems (BVPs).
Extensions to eigenvalue and periodic problems are already in progress;
we will document these in future releases.
%We believe the object-oriented framework we have set up generalizes
%gracefully to 

The accompanying tutorial is the best way to leap right in to using
the package.
The rest of this rather brief manual is more of a `top-down' document,
describing installation, the PDEs that may be solved,
our data structures and design choices, limitations, and acknowledgments.
As usual you
may also get help on any \mpspack\ command by typing {\tt help} followed
by the command name at the \matlab\ prompt.


\subsection{Installation}

Requirements: \matlab\ version 7.6 (2008a) or newer is needed,
since we make heavy use of recent object-oriented programming features.
No other \matlab\ toolboxes are needed.
If you wish to use faster regular Bessel functions you may want to
install the GNU Scientific Library \cite{GSL}.

The project is hosted at the repository
\co{http://code.google.com/p/mpspack}
There are two alternative methods to download and unpack:
\ben
\item
Ensure you have subversion ({\tt svn}) installed.
This is available from {\tt http://subversion.tigris.org}.
Anonymous check out (download) of \mpspack\ is then via the subversion
command:
\co{svn co http://mpspack.googlecode.com/svn/branches/release mpspack}
This creates a directory {\tt mpspack} containing the toolbox.

You might prefer a more user-friendly graphical
subversion client such as those listed at {\tt
http://subversion.tigris.org/links.html\#clients}

\item
Get a gzip-compressed tar archive from
\co{http://code.google.com/p/mpspack/downloads/list}
In a UNIX environment you may now
unpack this with
\co{tar zxvf mpspack.tar.gz}
This creates the directory {\tt mpspack} containing the toolbox.
\een
There are some optional fast basis and other math libraries
(C and Fortran with MEX interfaces), which should be compiled
in a UNIX environment as follows:
from the {\tt mpspack} directory type {\tt make}.
(If GSL \cite{GSL} is not installed, you will need to remove the
references to {\tt gsl} codes in {\tt @utils/Makefile} before
executing {\tt make}).

You should now add the {\tt mpspack}
directory to your \matlab\ path, for instance by adding the line
\co{addpath 'path/to/mpspack';}
to your MATLAB {\tt startup.m} file.
You are now ready to use \mpspack\ !


\subsection{What problems can \mpspack\ solve?}

Here we give a
general framework (for examples see \cite{mfs,polygonscatt}). 
Let $\Omega_j \subset \mathbb{R}^2$, $j=1,\ldots,D$ be a set of
(possibly multiply connected) domains. One of the domains may
be an exterior domain.
The solution domain is $\Omega:=\Omega_1 \cup \dots \cup \Omega_D$,
and we seek a solution $u:\Omega \to\mathbb{C}$.
In each domain we have,
\be
(\Delta+n_j^2k^2)u\; =\; 0 \qquad \mbox{in } \Omega_j~,
\ee
where the `overall wavenumber' (or frequency) $k$ has been scaled by
$n_j$ for each domain. In the optical application $n_j$ is interpreted
as a {\em refractive index} (with $n_j=1$ vacuum or air) and we
will use this name.

For all boundaries $\Gamma_j := \pO_j \cap \pO$
at the edge of the solution domain we have boundary conditions
\be
a_ju + b_j u_n\;=\;f_j\qquad \mbox{on } \Gamma_j~,
\ee
where $a_j, b_j \in \mathbb{C}$ are complex numbers (currently; in future they
may be functions on the boundary), and $f:\Gamma_j \to \mathbb{C}$ 
are (possibly homogeneous) driving functions.
$u_n$ is short for $\mbf{n}\cdot \nabla u$, the
normal derivative on the boundary.
If there is a nonempty
common boundary $\Gamma_{ij} := \pO_i \cap \pO_j$
then it may have value and derivative matching conditions,
\bea
%\left.\begin{array}{rcl}
a_{ij}^+ u^+ + a_{ij}^- u^- &=& f_{ij}\qquad \mbox{on } \Gamma_{ij}~,
\\
b_{ij}^+ u_n^+ + b_{ij}^- u_n^- &=& g_{ij}\qquad \mbox{on } \Gamma_{ij}~,
\eea
where $a_{ij}^+,a_{ij}^-,b_{ij}^+,b_{ij}^-$ are numbers
and $f_{ij}, g_{ij}$ are driving functions.
The notation $u^+$ ($u^-$) means the
limiting value approaching the boundary $\Gamma_{ij}$
from its positive (negative) normal side.
We assume all the boundaries $\Gamma_j$ and $\Gamma_{ij}$
are piecewise smooth, and each smooth piece we
will build from one or more {\em segments}.
If $\Omega_j$ is the exterior domain (with $n_j=1$), we may wish to impose
additional boundary conditions at infinity, such as Sommerfeld's
radiation condition,
\be
iku - \frac{\partial u}{\partial r} = o(r^{1/2})~,
\ee
where $r$ is the radial coordinate.
This occurs in the scattering context, where the unknown satisfying
the above BVP is now usually renamed $u_s$, and the total field
is then $u = u_{inc} + u_s$ with $u_{inc}$ the incident wave
\cite{coltonkress}.
As is standard with integral equation methods,
this is achieved by choosing basis sets (MFS, layer potentials, etc.)
satisfying the radiation condition.

To solve a BVP the flow using \mpspack\ is often as follows
(look back to the code given in Sec.~\ref{s:overview}):
\ben
\item define piecewise-smooth segments forming all boundaries
\item build domains using various of these segments as their boundaries
\item set up (in)homogeneous boundary or matching conditions on each segment
\item choose basis set(s) within each domain
\item build then solve a dense least-squares
linear system to get the basis coefficient vector
\item check residual error in satisfying boundary and matching conditions
\item evaluate and plot solution on desired points or grid
\een
The accompanying
tutorial document is a good way to explore these steps
in the context of examples.
We now discuss how software data structures represent the above objects.



\bfi % fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
\ig{width=\textwidth}{relat.eps}
\ca{Relationship of \mpspack\
objects used to solve a typical BVP.
The physical geometry is shown on the left, corresponding
code structures on the right.}{f:relat}
\efi


% --------------------------------------------------------------------------
\section{Objects: segments, domains, and basis sets}

Fig.~\ref{f:relat} overviews how segments, domains and basis sets are
represented in \mpspack\ in a simple example.
All coordinates in the plane are stored as complex double-precision
numbers. In other words the point 
$(2,3)$ and $2+3i$ represent the same point. This reflects
that

\subsection{Segments and pointsets}

A segment is specified as a parametrized function $z(t)$ for $0\le t\le 1$,
and $z'(t)$ is also needed.
If {\tt s} is a segment, these are stored as the properties
{\tt s.Z} and {\tt s.Zp} respectively.
Given a list {\tt s.t} of quadrature points on $[0,1]$
(and their weights),
the parametrization $z$ is used to compute quadrature point locations
{\tt s.x} and weights {\tt s.w}
for approximating integrals on the segment.
Unit normals {\tt s.nx} are computed when needed via the expression $iz'/|z'|$.%
  \footnote{A segment is in fact a
    subclass of a simpler object called a pointset.
    A pointset {\tt p} contains only a list of locations {\tt p.x}
    and possibly corresponding normal directions {\tt p.nx}.}
Since our focus is on high-order and accurate methods,
we feel that forcing the user to go to the trouble of providing $z$ and $z'$
is reasonable.%
  \footnote{In future releases we may allow $z$ and $z'$ to be automatically
    generated by high-order polynomial fits to a set of boundary points such
    as might be available from an engineering or CAD package.}
The benefit is that highly accurate quadrature is possible, and
the user may simply switch between quadrature schemes ({\tt s.quadr})
and numbers of points.

\subsection{Domains}

A domain object {\tt d} contains a list of segments which form its
outer boundary.
Each domain is built from
segments with a list of signs ($+$ or $-$) which define the sense in which
the segments are used to form the boundary.
Basis sets affect the function values inside each domain in which they
are referenced. A basis set may influence more than one domain.

When domains are built from segments, each segment stores information about
which domain, if any, it is connected to on each side.
If segments are to be reused to construct new domains, while erasing any
old domains, the current way to do this is via the {\tt s.disconnect}
command, where {\tt s} is a segment handle or array of such. This clears
these segments of any connections with domains.

The segment object field responsible for
this is {\tt s.dom}, which is a 1-by-2 cell array
of handles to the domain on the segment's natural normal side and
back side respectively. If there is no domain on a particular side, the
cell element is empty.


\subsection{Boundary conditions}


In our implementation the user
may supply these as handles to functions of segment parameter
$t\in[0,1]$, or as a data column vector on the segment quadrature points.

The segment fields {\tt a} and {\tt b} store
$a$ and $b$ for a boundary condition, or
$[a^+, a^-]$ and $[b^+, b^-]$
respectively for a matching condition.

\subsection{Basis sets}

FIX THIS TO REFLECT NEW basis.doms[] PROPERTY:

Each basis set has one (or possibly more) domain that it affects.


\footnote{apart from layer potentials which require a segment on which
their source density is placed}.
However, for a basis set to influence a domain {\tt d}, its handle must appear
in the cell array field {\tt d.bas}
This is set up automatically when you perform {\tt d.addregfbbasis()}
or any of the other 

There will be more elaborate basis set types which naturally affect two domains,
such as dielectric corner and transmission layer potential objects;
their handles will appear in the {\tt bas} cell array of more than one domain.

\section{Problem class objects}

Contain list of basis sets.
These are collected when domains are passed into a problem
constructor.

The row ordering in the matrix $A$ generated follows this list
of basis objects.


\section{Tweaks and test routines}

By default \mpspack\ uses robust rather than fast math libraries.
It is simple to switch to the following
faster alternatives, but the user should be careful
to check that the answers agree to their accuracy requirements.
%  \footnote{We give approximate runtimes below based on a
%    Intel Core Duo 2GHz laptop running Fedora 8 linux.}
\ben
\item Regular bessel functions, needed for {\tt regfbbasis.eval}.
Each {\tt regfbbasis} object contains a property {\tt besselcode}
that may be changed to {\tt 'r'} for Barnett's recurrence-relation
implementation (2-3 times faster the \matlab\ but
not guaranteed relative accuracy in
the deep evanescent region),
or {\tt 'g'} for MEX interface to GSL (nearly as fast as the recurrence
version, and robust).

\item Hankel functions of order 0 and 1, needed for
{\tt mfsbasis.eval} and {\tt layerpot.eval}. Both these basis objects
have a property {\tt fast} which may be 0 (\matlab\ implementation),
or 1 or 2 (a MEX interface to Greengard-Rokhlin's Fortran code,
roughly 5 times faster than \matlab).
The user may change this property for each relevant basis object.

\item Point-in-polygon checking is implemented by a MEX interface
to a C code which was found to be about 70 times faster than
\matlab. The implementation
may be switched only by uncommenting lines
in {\tt @utils/inpolywrapper.m}
\een

In the {\tt test/} directory you will find some routines that
we use to validate \mpspack. These are of variable quality,
but contain coding examples that you may find useful.
\bi
\item {\tt testbvp.m} shows the main steps for solution of a BVP on
a variety of domains.
\item
\ei


\section{Known bugs and limitations}

Current bugs and issues are listed at the repository site,

{\tt http://code.google.com/p/mpspack/issues/list}

Please alert the authors to any new
bugs that you discover, including a description
of how to reproduce the behavior, using this interface.

You may also contact the authors with suggestions
via their email addresses
given on the source page {\tt http://code.google.com/p/mpspack}

Limitations of, and planned future improvements to, the software include:

\bi
\item Two dimensions. Quadrature, decomposition into subdomains, and
corner singularities, the
main ideas upon which this toolbox is based, become much more complicated
in three dimensions. 
Implementing 3D problems would be a major undertaking.

\item Eigenvalue problems, one of the main reasons the authors became
interested in particular solutions methods, are not yet implemented.
For efficiency in symmetric domains, such as Bunimovich's stadium,
this would include
classes which symmetrize basis sets for single reflection, $C_4$, etc
symmetry, by wrapping the calls to basis evaluations using reflection
points.

\item The necessity to purchase commercial \matlab\ software.
However, there are no free mathematical environments that we know of
of comparable numerical versatility, plotting, and object-oriented capability.
One idea would be to port to the promising-looking {\tt SAGE} and {\tt python}
environment; get in touch if you would like to be involved.

\item Some better tools for problem set-up are needed, such as:
\bi
  \item Automatic meshing, based on complex approximation theory
  \item make {\tt domain.setbc} which uses one BC data function on all segments
  \item segment methods to create analytic interpolant function from boundary
point data, enabling user to specify a segment using points on a curve,
as in {\tt FMMToolbox}.
\ei

\item Checking of whether a point is inside a domain is approximate,
currently based on an approximating polygon of typically 50-100 sides
per segment object.
Better would be to use the segment parametrization function in
an iterative scheme, since this could give machine precision.

\item We have not tested complex wavenumber problems, which have
applications to conductive media. We expect that some of the
methods, such as layer potentials and fundamental solutions,
will carry over without modification.

\item Graded-index media problems, using Airy and other particular
solutions.

\item Better automated ways to choose MFS charge points given a domain,
based on \cite{mfs}.

\item Solution evaluation on boundary segments via {\tt segment.bdrysolution}
 which evaluates $u$, $u_n$ on one
or other side of a boundary.
This should then be used by {\tt problem.fillbcmatrix}

\item Incorporation of Fast Multipole Methods for evaluation with MFS and
layer potentials, and iterative
methods for second-kind layer potential formulations.

\item Saving
evaluation matrices for use with multiple right-hand sides.
Using QR factors of {\tt problem.A} matrix
for rapid solution with multiple right-hand sides.

\item Computation of far-field distribution in a scattering problem
from MFS or layer potential
representation of a radiating solution. This needs a variant of a
multipole-to-local matrix of regular bessel functions.
\ei

Please contact the authors if you implement any of these and/or want
to join the project!



\section{Acknowledgments and credits}

Almost all the code in \mpspack\ is written by 
Alex Barnett and Timo Betcke.
The concept and need for the package came out of our work in eigenvalue
and scattering problems, using global basis methods.
We have been influenced by, and learned useful tricks from,
the Schwarz-Christoffel toolbox by Toby Driscoll,
the {\tt FMMToolbox} by MadMax Optics, Inc.,
and the {\tt chebfun} system
by L. N. Trefethen, Z. Battles, T. Driscoll, R. Pach\'{o}n, and R. Platte.
Alex Barnett's work is supported by National Science Foundation
grants DMS-0507614 and DMS-0811005.
Timo Betcke's work is supported by XXX.

\mpspack\ is released under the GNU Public License, as follows:
\begin{verbatim}
Copyright (C) 2008, 2009, Timo Betcke, Alex Barnett

MPSpack is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

MPSpack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with MPSpack; if not, see <http://www.gnu.org/licenses>
\end{verbatim}

As part of the distribution (sometimes in order to
improve performance over native \matlab\ libraries),
we include codes written by others, as follows:
\bi
\item {\tt hank103.f} fast Hankel function computation, by
V.~Rokhlin and L.~Greengard.
\item {\tt kapurtrap.m} Kapur-Rokhlin periodic quadrature weights,
by Z.~Gambutas.
\item {\tt clencurt.m} and {\tt gauss.m}, quadrature nodes and weights,
by L.~N.~Trefethen \cite{tref}.
\item {\tt polypn.c} algorithm to check if a point is in a polygon,
Copyright (C) 1970-2003, Wm.~Randolph Franklin.
\item {\tt inpoly.m} algorithm to check if a point is in a polygon,
Darren Engwirda, 2005-2007.
\item {\tt copy.m} makes deep copy of \matlab\ handle object,
Doug M.~Schwarz, 6/16/08.
\ei


\bibliographystyle{siam} 
\bibliography{alexrefs}



\end{document}
