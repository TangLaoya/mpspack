\documentclass[12pt]{article}
\usepackage{graphicx,bm,amssymb,amsmath,amsthm}
\input{macros}

\begin{document}
\title{\mpspack\ user manual}
\author{Alex Barnett\footnote{Department of Mathematics, Dartmouth College, Hanover, NH, 03755, USA}
\ and Timo Betcke\footnote{Department of Mathematics,
University of Reading, Berkshire, RG6 6AX, UK}}
\date{\today}   % how pipe from getrevisionnumber + 1?

\maketitle
\begin{abstract}
\mpspack\ is a fully object-oriented \matlab\ toolbox for
solving Laplace, Helmholtz, wave scattering, and related PDE boundary-value
problems
on piecewise-homogeneous 2D domains, including those with corners.
The philosophy is to
%represent solutions using
use basis functions
which are particular solutions to the
PDE in some region; solving is thus reduced to matching on
the boundary (or on boundaries of subregions).
This idea is known as the Method of Particular Solutions, or as Trefftz,
ultra-weak, or non-polynomial 
methods in the FEM community.
Basis functions include plane-wave, Fourier-Bessel,
corner-adapted expansions, and
fundamental solutions.
Layer potential representations and associated
singular quadrature schemes are also available.
It is designed to
be simple to use, and to enable highly-accurate solutions.  This is
the user manual; for a more hands-on approach and worked examples
see the accompanying tutorial.
\end{abstract}


\bfi % ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
\ig{width=\textwidth}{hard.eps}
\ca{Sound-hard (homogeneous Neumann boundary condition) scattering from a smooth
obstacle using a fundamental solutions basis in \mpspack.
Left: incident wave. Center: scattered wave.
Right: total solution field.}{f:hard}
\efi


\section{Overview}
\label{s:overview}

In numerical analysis there has been recent excitement
in methods for solving linear PDEs where solutions are approximated by
linear combinations of {\em particular solutions} to the PDE.
These methods are high-order (often exponentially convergent),
efficient at high frequencies (the number of degrees of freedom $N$
scales linearly with wavenumber, in 2D),
and are quite simple to implement.
When geometries become more complicated, the domain needs to be split
up into multiple subdomains, e.g.\ one for each corner, and the
implementation and matrix construction becomes cumbersome.
The goal of this software toolbox is to make implementation of
these methods simple
and transparent, and create an intuitive, unifying framework in which many
types of boundary-value problems,
boundary conditions, and domain geometries
may be solved, explored and visualized with ease.
In these methods there is either no mesh (as in
fundamental solutions methods), or
the number of subdomains is small and fixed
(so-called $p$-FEM).
Thus we leave the job of specifying subdomains, i.e.\ `meshing',
to the user---this contrasts with the large number of
finite-element packages already in existence.
The benefit of such methods is their rapid convergence and efficiency.
The solution boils down to dense least-squares linear algebra,
which despite the $O(N^3)$ cost enables some quite high-frequency problems
to be solved.

We focus on the scalar homogeneous
Helmholtz equation in the plane,
\bea
(\Delta+k^2)u& =& 0 \qquad \mbox{in } \Omega~,
\eea
where $\Omega \subset \mathbb{R}^2$ is an interior or exterior
domain, $k\ge 0$ is the wavenumber, and certain
%imhomogeneous
linear boundary conditions are imposed.
Such problems arise in wave scattering and cavity resonances.
In \mpspack\ we use the (recently-acquired)
power of \matlab\ \cite{matlab} {\em object-oriented}
programming to represent the 
mathematical objects such as segments, domains,
basis sets, and BVPs, by software objects that may be manipulated
just like variables.
The result is that complicated problems may be set up and solved in
a few lines of quite-readable code.
For example, to solve and plot the scattering
of plane-wave incident from a smooth sound-hard (Neumann) domain
10 wavelengths in size, we can type,
\begin{verbatim}
s = segment.radialfunc(250, {@(q) 1 + 0.3*cos(3*q), @(q) -0.9*sin(3*q)});
d = domain([], [], s, -1);
s.setbc(1, 'N', []);
opts.tau = 0.04; d.addmfsbasis(s, 210, opts);
p = scattering(d, []);
p.setoverallwavenumber(30);
p.setincidentwave(pi/6);
p.solvecoeffs;
p.showthreefields;
\end{verbatim}
which produces Fig.~\ref{f:hard} in about 1 sec of CPU time,
to an accuracy of $10^{-9}$ (boundary condition $L^2$-norm).

More generally we may have multiple domains with different
wavenumbers connected by homogeneous or inhomogeneous boundary conditions,
as in transmission, dielectric-coated, acoustic or photonics problems.
With $k=0$ we have Laplace's equation, with applications to
electrostatics, steady-state heat flow, and probability.
In this release we discuss only boundary-value problems (BVPs).
Extensions to eigenvalue and periodic problems are already in progress;
we will document these in future releases.
%We believe the object-oriented framework we have set up generalizes
%gracefully to 

The accompanying tutorial is the best way to leap right in to using
the package.
The rest of this rather brief manual is more of a `top-down' document,
describing installation, the PDEs that may be solved,
our data structures and design choices, limitations, and acknowledgments.
As usual you
may also get help on any \mpspack\ command by typing {\tt help} followed
by the command name at the \matlab\ prompt.


\subsection{Installation}

Requirements: \matlab\ version 7.6 (2008a) or newer is needed,
since we make heavy use of recent object-oriented programming features.
No other \matlab\ toolboxes are needed.
If you wish to use faster regular Bessel functions you may want to
install the GNU Scientific Library \cite{GSL}.

The project is hosted at the repository
\co{http://code.google.com/p/mpspack}
There are two alternative methods to download and unpack:
\ben
\item
Ensure you have subversion ({\tt svn}) installed.
This is available from {\tt http://subversion.tigris.org}.
Anonymous check out (download) of \mpspack\ is then via the subversion
command:
\co{svn co http://mpspack.googlecode.com/svn/branches/release mpspack}
This creates a directory {\tt mpspack} containing the toolbox.

You might prefer a more user-friendly graphical
subversion client such as those listed at {\tt
http://subversion.tigris.org/links.html\#clients}

\item
Get a gzip-compressed tar archive from
\co{http://code.google.com/p/mpspack/downloads/list}
In a UNIX environment you may now
unpack this with
\co{tar zxvf mpspack.tar.gz}
This creates the directory {\tt mpspack} containing the toolbox.
\een
There are some optional fast basis and other math libraries
(C and Fortran with MEX interfaces), which should be compiled
in a UNIX environment as follows:
from the {\tt mpspack} directory type {\tt make}.
(If GSL \cite{GSL} is not installed, you will need to remove the
references to {\tt gsl} codes in {\tt @utils/Makefile} before
executing {\tt make}).

You should now add the {\tt mpspack}
directory to your \matlab\ path, for instance by adding the line
\co{addpath 'path/to/mpspack';}
to your MATLAB {\tt startup.m} file.
You are now ready to use \mpspack\ !


\subsection{What problems can \mpspack\ solve?}

Here we give a
general framework (for examples see \cite{mfs,polygonscatt}). 
Let $\Omega_j \subset \mathbb{R}^2$, $j=1,\ldots,D$ be a set of
(possibly multiply connected) domains. One of the domains may
be an exterior domain.
The solution domain is $\Omega:=\Omega_1 \cup \dots \cup \Omega_D$,
and we seek a solution $u:\Omega \to\mathbb{C}$.
In each domain we have,
\be
(\Delta+n_j^2k^2)u\; =\; 0 \qquad \mbox{in } \Omega_j~,
\ee
where the `overall wavenumber' (or frequency) $k$ has been scaled by
$n_j$ for each domain. In the optical application $n_j$ is interpreted
as a {\em refractive index} (with $n_j=1$ vacuum or air) and we
will use this name.

For all boundaries $\Gamma_j := \pO_j \cap \pO$
at the edge of the solution domain we have boundary conditions
\be
a_ju + b_j u_n\;=\;f_j\qquad \mbox{on } \Gamma_j~,
\label{e:bc}
\ee
where $a_j, b_j \in \mathbb{C}$ are complex numbers (currently; in future they
may be functions on the boundary), and $f:\Gamma_j \to \mathbb{C}$ 
are (possibly identically zero) driving functions.
$u_n$ is short for $\mbf{n}\cdot \nabla u$, the
normal derivative on the boundary.%
  \footnote{Within this framework it is possible to have domains with
    `slits' or cracks, as long as each side of the crack
    is defined to be a different part of $\Gamma_j$.}
If there is a nonempty
{\em common} boundary $\Gamma_{ij} := \pO_i \cap \pO_j$
then it has value and derivative matching (continuity) conditions,
\bea
%\left.\begin{array}{rcl}
a_{ij}^+ u^+ + a_{ij}^- u^- &=& f_{ij}\qquad \mbox{on } \Gamma_{ij}~,
\label{e:match}
\\
b_{ij}^+ u_n^+ + b_{ij}^- u_n^- &=& g_{ij}\qquad \mbox{on } \Gamma_{ij}~,
\label{e:matchn}
\eea
where $a_{ij}^+,a_{ij}^-,b_{ij}^+,b_{ij}^-$ are numbers
and $f_{ij}, g_{ij}$ are driving functions.
The notation $u^+$ ($u^-$) means the
limiting value approaching the boundary $\Gamma_{ij}$
from its positive (negative) normal side.

We assume all the boundaries $\Gamma_j$ and $\Gamma_{ij}$
are piecewise smooth, and each smooth piece we
will build from one or more {\em segments}.
If $\Omega_j$ is the exterior domain (with $n_j=1$), we may wish to impose
additional boundary conditions at infinity, such as Sommerfeld's
radiation condition,
\be
iku - \frac{\partial u}{\partial r} = o(r^{1/2})~,
\ee
where $r$ is the radial coordinate.
This occurs in the scattering context, where the unknown satisfying
the above BVP is now usually renamed $u_s$, and the total field
is then $u = u_{inc} + u_s$ with $u_{inc}$ the incident wave
\cite{coltonkress}.
As is standard with integral equation methods,
this is achieved by choosing basis sets (MFS, layer potentials, etc.)
satisfying the radiation condition.

To solve a BVP the flow using \mpspack\ is often as follows
(look back to the code given in Sec.~\ref{s:overview}):
\ben
\item define piecewise-smooth segments forming all boundaries
\item build domains using various of these segments as their boundaries
\item set up (in)homogeneous boundary or matching conditions on each segment
\item choose basis set(s) within each domain
\item build then solve a dense least-squares
linear system to get the basis coefficient vector
\item check residual error in satisfying boundary and matching conditions
\item evaluate and plot solution on desired points or grid
\een
The accompanying
tutorial document is a good way to explore these steps
in the context of examples.
We now discuss how software data structures represent the above objects.



\bfi % fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
\ig{width=\textwidth}{relat.eps}
\ca{Relationship between segments, domains,
and basis sets in a simple example.
The physical geometry is shown on the left. There is a regular
Fourier-Bessel basis in domain {\tt d}, and a layer-potential
density on segment {\tt p} which affects both domains {\tt d} and {\tt e}.
The corresponding
code objects are on the right.
Pointers to the four segments, two domains, and two basis sets are
stored within the problem instance.}{f:relat}
\efi


% --------------------------------------------------------------------------
\section{Objects: segments, domains, and basis sets}

Fig.~\ref{f:relat} overviews how segments, domains and basis sets are
represented in \mpspack\ in a simple example.
For all these objects we use \matlab's {\tt handle} class,
which means that only a single copy of any object instance is
stored, and any time an instance is copied or passed as a function argument,
it is a {\em pointer} to that instance that is duplicated.
(This contrasts the {\tt value} class, such as numeric variables,
in which the {\em actual data} is duplicated when copied or passed as an
argument.)
Thus each domain stores (as one of its properties)%
  \footnote{A {\em property} is a variable stored inside the
    object instance, just like a field {\tt a.b} inside a struct {\tt a}.}.
an array of pointers to the
segments forming its boundary.
It also stores a cell array of the basis sets that
contribute to the solution inside it.
Each basis set stores a list of the domains it affects---usually
this is a single domain.
There are also boundary conditions stored in
each segment, which are not shown.
The `problem' object (BVP, scattering problem, etc) contains arrays of
(pointers to) all relevant segments, domains, and basis sets.
{\em Methods} (i.e. commands available which act on the problem class)
then use this internal information to, for instance,
construct a matrix and solve the problem.

\subsection{Segments} % and pointsets}

All coordinates in the plane are stored as complex double-precision
numbers. In other words the point 
$(2,3)$ is represented by $2+3i$ in \mpspack.
A segment is specified as a parametrized complex-valued
function $z(t)$ for $0\le t\le 1$, and $z'(t)$ is also needed.
If {\tt s} is a segment, these are stored as the properties
{\tt s.Z} and {\tt s.Zp} respectively.
Given a list {\tt s.t} of quadrature points on $[0,1]$
(and their weights),
the parametrization $z$ is used to compute quadrature point locations
{\tt s.x} and weights {\tt s.w}
for approximating integrals with respect to arc-length on the segment.
Unit normals {\tt s.nx} are computed when needed via the expression $iz'/|z'|$,
which shows that a segment's normal always points to the {\em right}
when the segment is traversed in its natural direction (increasing $t$);
see Fig.~\ref{f:relat}.%
  \footnote{A segment is in fact a
    subclass of a simple object we call a pointset.
    A pointset {\tt p} contains only a list of locations {\tt p.x}
    and possibly corresponding normal directions {\tt p.nx}.}
Since our focus is on high-order and accurate methods,
we feel that forcing the user to go to the trouble of providing $z$ and $z'$
is reasonable.%
  \footnote{In future releases we may allow $z$ and $z'$ to be automatically
    generated by high-order polynomial fits to a set of boundary points such
    as might be available from an engineering or CAD package.}
The benefit is that highly accurate quadrature is possible, and
the user may simply switch between quadrature schemes ({\tt s.quadr})
and numbers of points.

Segments start out their lives {\em unconnected} to any domains,
as evidenced by two empty elements as their domain connection
property cell-array {\tt s.dom\{1\} = []} and {\tt s.dom\{2\} = []}.

\subsection{Domains}

A domain object {\tt d} contains as properties
an ordered list of segments {\tt d.segs} which form its
boundary, and an equal-sized
list {\tt d.pm} of {\em senses} ($\pm1$)
specifying whether each segment is to be taken in its `forward'
(natural, $+1$) direction, or `backward' (reverse, $-1$) direction.
All segments taken in these (possibly reversed) senses must
i) connect up head to tail in the correct order,
in one or more connected closed loops,
and ii) have the domain interior lying to its left side when traversed
according to its sense.
The latter ensures that the segment normals, {\em when multiplied by the
corresponding senses}, always point {\em outwards} (away) from
the domain.
At this point the reader would be wise to
check they are able to write down correctly from the geometry
the {\tt pm} arrays in Fig.~\ref{f:relat}.

In order to distinguish disconnected components of the boundary of
{\tt d}, the list {\tt d.spiece} specifies which boundary piece each
segment is part of. E.g.\ {\tt spiece = [1 1 2 3]} means
there are three boundary pieces, the first involving
two segments, and the other two only one segment each.
If {\tt s.exterior = 0}
then the domain is not an exterior domain, thus we could deduce that
there is an outer boundary (which is always the first piece, and 
taking into account senses is traversed in a CCW direction)
with two excluded regions (each traversed in a CW direction).
On the other hand, if {\tt s.exterior = 1} the domain is the whole plane
with three disjoint excluded regions (each in a CW direction).
We recommend now looking at the plots produced by
{\tt test/testdomain.m} and examining their object properties
at the command prompt.

Each domain also contains a list of corners where segments meet:
the first corner is where the
end of the last segment of piece 1 joins the start of the first segment
of piece 1. Subsequent corners follow in the same order as segments.
The angles (in radians) subtended by each 
corner on the domain interior side are in {\tt d.cang}, and their
locations in {\tt d.cloc}.
The angle at which segment {\tt d.seg(j)}
`heads off in' at its start (when taken in the sense given by
{\tt pm} as above) is {\tt d.cangoff(j)},
expressed as a complex number on the unit circle.
The advantage of domains containing corner information is that
corner-adapted basis sets may automatically be added.

When a domain is constructed by passing in lists of segments
and senses, the relevant segment's side is {\em connected} to the domain.
E.g.\ if the natural positive side of segment {\tt s} has been used
as a boundary (approaching from the interior) of domain {\tt d},
we find {\tt s.dom\{1\} = d}.
This bookkeeping is used to ensure that each side of a segment
can only be connected to at most one domain.
If a domain-connected segment {\tt s} is to be reused making new domains,
one must first run the method {\tt s.disconnect}
which empties both elements of the {\tt s.dom} cell array.


\subsection{Boundary conditions}

These are stored on a per-segment basis, as properties of each segment
instance. A boundary condition (BC) may reside on only {\em one} side of a
segment (\mpspack\ checks that this side is connected to a domain),
as specified by the {\tt bcside} property.
{\tt s.bcside = +1} indicates a BC on the natural (positive
normal) side of segment {\tt s}, and {\tt s.bcside = -1} a BC on the
opposite (negative normal) side.
(This is independent of any of the {\tt pm} senses stored in the connected
domains.)
Then the numbers {\tt s.a}, {\tt s.b},
and function handle {\tt s.f} give the
$a_j$ and $b_j$ coefficients and function $f_j$ from \eqref{e:bc}.

If {\tt s.bcside = 0} this indicates a matching condition
\eqref{e:match} and \eqref{e:matchn} rather than a BC. In this case,
{\tt s.a} contains a 2-element array with coefficients
$[a^+, a^-]$ from \eqref{e:match}, {\tt s.b} contains
$[b^+, b^-]$ from \eqref{e:matchn},
and {\tt s.f} and {\tt s.g} contain the functions $f$ and $g$.

In the above, function handles may be replaced by a list (column vector)
of function {\em values}
at the quadrature points (however, now the user must ensure that, if
the quadrature points change, that these function values are updated).


\subsection{Basis sets}

A basis set object {\tt b} affects the
function values inside the domain in the pointer {\tt b.doms}.%
  \footnote{In fact, {\tt doms} may be a list, but currently only obscure
    layer potential objects have the power to influence more than
    one domian. Therefore we discuss only the simpler
    case of one affected domain.}
When a basis set is {\em added} to a basis-set-free domain {\tt d},
two things happen: i) a new instance of the appropriate basis class
is created, with {\tt d.bas\{1\}} pointing to this basis object,
and ii) this basis object has property {\tt doms} set to {\tt d}.
These pointers in both directions are shown in Fig.~\ref{f:relat},
and help later bookkeeping to be rapid (i.e.\ free of searches).

The types of basis objects currently implemented are
\bi
\item Regular Fourier-Bessel expansions.
[GIVE FORMULAE]
\item Fractional-order (corner or wedge) Fourier-Bessel expansions.
\item Sets of real (as opposed to evanescent) plane waves.
\item Sets of fundamental solutions with different origins (charge points),
both monopole and dipole.
Use $\Phi$
\item Single- and double-layer potentials lying on segments.
\be
u(\bx) = {\cal S}\sigma (\bx) := \int_\Gamma \Phi(\bx-\by) \sigma(\by) ds_\by
\ee
where $ds$ is arclength, or double-layer potential (DLP) density
\be
u(\bx) = {\cal D}\tau (\bx)
:= \int_\Gamma \frac{\partial \Phi(\bx-\by)}{\partial n_\by} \tau(\by) ds_\by
\ee
where $\Gamma$ is a segment, and $\sigma$ and $\tau$ are functions on $\Gamma$.

\ei
Here the fundamental solution is
\be
        \Phi(\bx) = \frac{i}{4}H_0^{(1)} (k|\bx|)
\label{e:fund}
\ee
A basis set {\tt b} is evaluated at a set of points {\tt x}
using {\tt b.eval(pointset(x))}.
OR a segment or previously-defined pointset may be used.
All basis sets are evaluated in a reasonably efficient manner.

Apart from plane waves, they all degenerate to meaningful basis sets
in the limit $k=0$ (Laplace's equation)
as follows.



% --------------------------------------------------------------------------
\section{Solution methods and problem class objects}

Contain list of basis sets.
These are collected when domains are passed into a problem
constructor.
[ARE DOMAINS ACTUALLY NEEDED TO BE STORED AS PROBLEM PROPERTIES?
if a domain is not affected by any basis set, it is not in the problem, right?]

The column ordering in the matrix $A$ generated follows this list
of basis objects.
This defines the ordering in the coefficient vector {\tt p.co}.

The row ordering is given by the segment list in the problem.
Segments are uniquely extracted from the domain list.

\subsection{BVPs}


sets up BCs and matching based on refractive indices

constructs a RHS in same ordering as 

evaluates solution by checking 

\subsection{Scattering problems}

a subclass of {\tt bvp}.

air domains, choose how $u_{inc}$ is converted into
inhomogeneous matching conditions and BCs.
Constructor format of air vs nonair domains.

It also has properties: incident wave, 

Has showthreefields.


% --------------------------------------------------------------------------
\section{Tweaks and test routines}

By default \mpspack\ uses robust rather than fast math libraries.
It is simple to switch to the following
faster alternatives, but the user should be careful
to check that the answers agree to their accuracy requirements.
%  \footnote{We give approximate runtimes below based on a
%    Intel Core Duo 2GHz laptop running Fedora 8 linux.}
\ben
\item Regular bessel functions, needed for {\tt regfbbasis.eval}.
Each {\tt regfbbasis} object contains a property {\tt besselcode}
that may be changed to {\tt 'r'} for Barnett's recurrence-relation
implementation (2-3 times faster the \matlab\ but
not guaranteed relative accuracy in
the deep evanescent region),
or {\tt 'g'} for MEX interface to GSL (nearly as fast as the recurrence
version, and robust).

\item Hankel functions of order 0 and 1, needed for
{\tt mfsbasis.eval} and {\tt layerpot.eval}. Both these basis objects
have a property {\tt fast} which may be 0 (\matlab\ implementation),
or 1 or 2 (a MEX interface to Greengard-Rokhlin's Fortran code,
roughly 5 times faster than \matlab).
The user may change this property for each relevant basis object.

\item Point-in-polygon checking is implemented by a MEX interface
to a C code which was found to be about 70 times faster than
\matlab. The implementation
may be switched only by uncommenting lines
in {\tt @utils/inpolywrapper.m}
\een

In the {\tt test/} directory you will find some routines that
we use to validate \mpspack. These are of variable quality,
but contain coding examples that you may find useful.
\bi
\item {\tt testdomain.m} builds and plots nine domains of increasing
complexity.
\item {\tt testbvp.m} shows the main steps for solution of a BVP on
a variety of domains.
\item
\ei


\section{Known bugs and limitations}

Current bugs and issues are listed at the repository site,

{\tt http://code.google.com/p/mpspack/issues/list}

Please alert the authors to any new
bugs that you discover, including a description
of how to reproduce the behavior, using this interface.

You may also contact the authors with suggestions
via their email addresses
given on the source page {\tt http://code.google.com/p/mpspack}

Limitations of, and planned future improvements to, the software include:

\bi
\item Two dimensions. Quadrature, decomposition into subdomains, and
corner singularities, the
main ideas upon which this toolbox is based, become much more complicated
in three dimensions. 
Implementing 3D problems would be a major undertaking.

\item Eigenvalue problems, one of the main reasons the authors became
interested in particular solutions methods, are not yet implemented.
For efficiency in symmetric domains, such as Bunimovich's stadium,
this would include
classes which symmetrize basis sets for single reflection, $C_4$, etc
symmetry, by wrapping the calls to basis evaluations using reflection
points.

\item The necessity to purchase commercial \matlab\ software.
However, there are no free mathematical environments that we know of
of comparable numerical versatility, plotting, and object-oriented capability.
One idea would be to port to the promising-looking {\tt SAGE} and {\tt python}
environment; get in touch if you would like to be involved.

\item Some better tools for problem set-up are needed, such as:
\bi
  \item Automatic meshing, based on complex approximation theory
  \item make {\tt domain.setbc} which uses one BC data function on all segments
  \item segment methods to create analytic interpolant function from boundary
point data, enabling user to specify a segment using points on a curve,
as in {\tt FMMToolbox}.
\ei

\item Checking of whether a point is inside a domain is approximate,
currently based on an approximating polygon of typically 50-100 sides
per segment object.
Better would be to use the segment parametrization function in
an iterative scheme, since this could give machine precision.

\item We have not tested complex wavenumber problems, which have
applications to conductive media. We expect that some of the
methods, such as layer potentials and fundamental solutions,
will carry over without modification.

\item Graded-index media problems, using Airy and other particular
solutions.

\item Better automated ways to choose MFS charge points given a domain,
based on \cite{mfs}.

\item Solution evaluation on boundary segments via {\tt segment.bdrysolution}
 which evaluates $u$, $u_n$ on one
or other side of a boundary.
This should then be used by {\tt problem.fillbcmatrix}

\item Incorporation of Fast Multipole Methods for evaluation with MFS and
layer potentials, and iterative
methods for second-kind layer potential formulations.

\item Saving
evaluation matrices for use with multiple right-hand sides.
Using QR factors of {\tt problem.A} matrix
for rapid solution with multiple right-hand sides.

\item Computation of far-field distribution in a scattering problem
from MFS or layer potential
representation of a radiating solution. This needs a variant of a
multipole-to-local matrix of regular bessel functions.
\ei

Please contact the authors if you implement any of these and/or want
to join the project!



\section{Acknowledgments and credits}

Almost all the code in \mpspack\ is written by 
Alex Barnett and Timo Betcke.
The concept and need for the package came out of our work in eigenvalue
and scattering problems, using global basis methods.
We have been influenced by, and learned useful tricks from,
the Schwarz-Christoffel toolbox by Toby Driscoll,
the {\tt FMMToolbox} by MadMax Optics, Inc.,
and the {\tt chebfun} system
by L. N. Trefethen, Z. Battles, T. Driscoll, R. Pach\'{o}n, and R. Platte.
Alex Barnett's work is supported by National Science Foundation
grants DMS-0507614 and DMS-0811005.
Timo Betcke's work is supported by XXX.

\mpspack\ is released under the GNU Public License, as follows:
\begin{verbatim}
Copyright (C) 2008, 2009, Timo Betcke, Alex Barnett

MPSpack is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

MPSpack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with MPSpack; if not, see <http://www.gnu.org/licenses>
\end{verbatim}

As part of the distribution (sometimes in order to
improve performance over native \matlab\ libraries),
we include codes written by others, as follows:
\bi
\item {\tt hank103.f} fast Hankel function computation, by
V.~Rokhlin and L.~Greengard.
\item {\tt kapurtrap.m} Kapur-Rokhlin periodic quadrature weights,
by Z.~Gambutas.
\item {\tt clencurt.m} and {\tt gauss.m}, quadrature nodes and weights,
by L.~N.~Trefethen \cite{tref}.
\item {\tt polypn.c} algorithm to check if a point is in a polygon,
Copyright (C) 1970-2003, Wm.~Randolph Franklin.
\item {\tt inpoly.m} algorithm to check if a point is in a polygon,
Darren Engwirda, 2005-2007.
\item {\tt copy.m} makes deep copy of \matlab\ handle object,
Doug M.~Schwarz, 6/16/08.
\ei


\bibliographystyle{siam} 
\bibliography{alexrefs}



\end{document}
